decoder {
    n=remote_1,m=OOK_PPM,s=312,l=1072,r=6820,g=6000,t=304,y=0,
    luacode=[[
	print("Loading validate && decode")
	function validate(data)
	  local result = {} --
	  for _, buffer in ipairs(data) do
	    if buffer:bitlen() >= 16 and buffer:bitlen() <= 18 then
	      if buffer[{0, 8}] + buffer[{8, 8}] == 255 then
		table.insert(result, BitBuffer.new(buffer, 16))
	      end
	    end
	  end
	  return result
	end

	local keyMap = {
	  [0x32] = "off",
	  [0x33] = "+",
	  [0x34] = "up",
	  [0x35] = "on",
	  [0x36] = "-",
	  [0x37] = "down"
	} --

	function decode(data)
	  res = {} --
	  res.key = keyMap[data[1][{8, 8}]] or data[1][{8, 8}]
	  return res
	end
	local packet = BitBuffer.new(string.char(0xCB, 0x34), 16)
	assert(validate({packet})[1] == packet, "Incorrect packet validation")
	assert(decode({packet}).key == "up", "Key value not 'up'")
]]
}

decoder {
    n=remote_2,m=OOK_PPM,s=312,l=1072,r=6820,g=6000,t=304,y=0,
    luacode=[[
	-- 11000101 01101010
       local s = BitBuffer.new(string.char(0xc5, 0x6a), 16);

       assert(s:bitlen() == 16, "Size check")

       assert(s[0] == 1, "single bit access")
       assert(s[11] == 0, "single bit access")
       assert(s[{11, -8}] == 0x6a, "reversed access")

       function doit (p, s, o, w, b, v, r) 
           assert(s[{o,w, little_endian_value=v, little_endian_buffer=b}] == r, "invalid extraction")
           s:little_endian_buffer(b)
           s:little_endian_value(v)
           print(p, string.format("0x%X 0x%X", s[{o, w}], r))
           assert(s[{o,w}] == r, "invalid extraction")
           local rsigned = r
           if r & (1 << (w - 1)) ~= 0 then
	       rsigned = r | (-1 << w)
           end
              
           assert(s[{o,w,signed=1}] == rsigned, "invalid signed extraction")
           assert(s:getbits({offset=o,width=w,little_endian_buffer=b,little_endian_value=v}) == r, "invalid getbits result")
           assert(s[{o+w-1, -w, little_endian_value=not v}] == r, "failed negative bitwidth")
       end

       doit("big/big", s, 4, 8, false, false, 0x56)
       doit("little/little", s, 4, 8, true, true, 0xAC)
       doit("big/little", s, 4, 8, false, true, 0x6A)
       doit("little/big", s, 4, 8, true, false, 0x35)

       -- 11000101 01101010 01111011
       -- BIG: 001 0101 1010 1001
       -- LTL: 000 1101 0101 1011
       s = BitBuffer.new(string.char(0xc5, 0x6a, 0x7b), 24)

       doit("big/big", s, 3, 15, false, false, 0x15a9)
       doit("little/little", s, 3, 15, true, true, 0x6d58)
       doit("big/little", s, 3, 15, false, true, 0x4ad4)
       doit("little/big", s, 3, 15, true, false, 0xd5b)

]]
}
